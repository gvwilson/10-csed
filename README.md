# Ten Simple Rules for Computing Education

1. Live coding
 - Allows learners to see the process, not just the end result
   - Including mistakes, and how to fix them.  (Too much practice bad here: you stop making unplanned mistakes)
 - More engaging than static slides of code.
 - Can be overused, I think: no point just typing out code like from one of the 80s Osborne books, you need to be coding for the purpose of explanation.

2. Get students to make predictions
 - Being wrong stings!  Which is good.  Easy to brush it off if you haven't made prediction public.
 - Research on how students misremembered physics demos afterwards.
 - More engaging if you have to have to think about it and take an action.

3. Peer instruction
 - Mazur's work, built on by B. Simon, Cutts, etc.
 - Can be a problem if ability levels differ widely (as in intro CS undergrad)?

4. Pair programming

5. Subgoal labelling
 - Lets you give students many different specific problems, while making clear the higher-level isomorphisms between the problems.
 - Without subgoal labels, learners don't always see the spirals in a spiral curriculum.
 - There is a complex result in the Morrison, Guzdial work about writing your own labels.  May be too intricate to include?

6. Stick with one language
 - Broad principle: knowledge only transfers when you achieve mastery.  Attempting transfer too early breaks knowledge/confidence.

7. Engaging context (media computation, etc.)
 - ITiCSE report says context makes no difference to task performance.
 - I think the media comp result shows that context increases motivation.
 - No downside, plus upside => worth having good context.  But context can easily exclude people, so be careful.

8. Use worked examples
 - Like live coding, lets learners see process not just end result.

8. Don't just code (Parson's problems)
 - Writing code blows learners' minds (in terms of cognitive load).  Syntax, semantics, algorithm, design, etc.
 - Smaller tasks (parson's, code tracing, multiple choice questions) reduce the scope (no pun) of task to something manageable.

9. Start with blocks
 - Evidence generally points to blocks being better than text.
 - This can conflict with context though, and you may encounter resistance from learners (inauthenticity, etc)

10. There's no geek gene (Patitsas et al)

And two we can't prove yet (well, that we need to go check the literature for proof):

- Don't start with a blank screen
  - Blank screen is very intimidating.
  - Related to earlier point about not just coding: editing existing program is different task to writing new one from nothing.
  - Difficult balancing act: large programs can also intimidate learners; you need a path through the program they can follow.
  - Thus good for intermediate students?  Those who know syntax and semantics but struggling with algorithms and program design.
  - Authentic context for those who will continue: more likely to work with existing codebases than new codebases.

- Programming tools matter
  - Different tools have different capabilities and affordances.  How could they not matter?  But has anyone done the research...?
