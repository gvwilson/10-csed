\documentclass{article}
\usepackage[a4paper]{geometry}
\usepackage{natbib}
\usepackage{hyperref}

\title{Ten Simple Rules for Teaching Programming}
\author{Neil C. C. Brown\footnote{King's College London / neil.c.c.brown@kcl.ac.uk} and Greg Wilson\footnote{Rangle.io / gvwilson@third-bit.com}}

\begin{document}

\maketitle

\section*{Introduction}

Research from educational psychology suggests that teaching and learning are subject-specific
activities~\citep{mayer-subject}: learning programming has a different set of challenges and techniques
than learning physics or learning to read and write.  Computing is a younger discipline than
mathematics, physics, or biology, and while there have been correspondingly fewer studies of how best to teach it,
there is a growing body of evidence about what works and doesn't.
This paper presents ten simple rules that should be the foundation of any teaching, whether
formal or informal.

% FIXME: mention Repenning's boring/exciting X hard/easy framework from "Moving Beyond Syntax" paper.

\section{There is no geek gene}\label{gene}

\citet{guzdial-myths} refers to the belief that some people are born programmers and others aren't
as ``computing's most enduring and damaging myth.''
Our first and most important rule is that this is wrong:
competence at programming is not innate,
but is rather a learned skill that can be acquired and improved with practice.

The most powerful evidence for this comes from \citet{patitsas-bimodal}.
They examined grade distributions in introductory computing courses at a large university,
and found that only 5.8\% were actually multi-modal.
More damningly,
they found that computer science faculty were more likely to see distributions as bimodal
if they thought those grades came from a programming class
than if they believed the grades came from some other kind of class,
and that those faculty were even more likely to see the distributions as bimodal
if they believed some students are innately predisposed to do well in computer science.

Beliefs such as this are known to have powerful effects on education outcomes
\cite{alvidrez-weinstein,brophy,jussim-eccles}.
If instructors believe that ``some kids get it and some kids don't'',
they will (consciously or unconsciously) invest less in those whom they put in the second category.
When combined with cultural stereotypes about who is and isn't a "natural programmer",
the downward spiral of under-achievement that results from differential attention
may be partly responsible for the gender imbalance in computing.

\section{Use peer instruction}\label{peer-instruction}

No matter how good teachers are,
they can only say one thing at a time.
How then can they clear up learners' many different misconceptions
in a reasonable time?

The best method developed so far is called peer instruction.
Originally created by Eric Mazur at Harvard~\citep{mazur-peer-instruction},
it has been studied extensively in a wide variety of contexts,
including programming \cite{porter,cutts}
In simplified form,
peer instruction proceeds in three phases:

\begin{enumerate}

\item The instructor gives learners a brief introduction to the topic.

\item The instructor then gives learners a multiple choice question
   that probes for misconceptions rather than simple factual recall.

\item Learners then vote on the answer to the question.

  \begin{itemize}
  \item If they all have the right answer, move on.
  \item If they all have the same wrong answer,
    the instructor addresses that specific misconception.
  \item If they have a mix of right and wrong answers,
    they are given several minutes to discuss those answers with one another
    in small groups (typically 2-4 students)
    and then reconvene and vote again.
  \end{itemize}

\end{enumerate}

Peer instruction is essentially
a way to provide one-to-one mentorship in a scalable way.
Group discussion significantly improves learners' understanding
because it forces them to clarify their thinking,
which can be enough to call out gaps in reasoning.
Re-polling the class then lets the instructor know if they can move on,
or if further explanation is necessary.
While it significantly outperforms lecture-based instruction in most situations,
it can be problematic if ability levels differ widely
(as they often do in introductory programming classes
because of varied prior experience).
Pair programming (Rule~\ref{pair-programming}) can be used to mitigate this.

\section{Use live coding}\label{live-coding}

Rather than using slides,
create programs in front of their learners~\cite{rubin-live-coding}.
This is more effective for multiple reasons:

\begin{enumerate}

\item It enables instructors to be more responsive to ``what if?''
  questions. Where a slide deck is like a railway track, live coding
  allows instructors to go off road and follow their learners'
  interests.

\item It facilitates unintended knowledge transfer: students learn more
  than the instructor consciously intends to teach by watching \textit{how}
  instructors do things.

\item It slows the instructor down: if they has to type in the program
  as they go along, they can only go twice as fast as their
  learners, rather than ten-fold faster as they could with slides.

\item Learners get to how instructors diagnose and correct
  mistakes. Novices are going to spend most of their time doing
  this, but it's left out of most textbooks.

\item Watching instructors make mistakes shows learners that it's all
  right to make mistakes of their own~\citep{barker-live-coding}.
  Most people model the behavior of their teachers: if the instructor
  isn't embarrassed about making and talking about mistakes, learners
  will be more comfortable doing so too.

\end{enumerate}

Live coding does have some drawbacks, but with practice, these can be
avoided or worked around:

\begin{enumerate}

\item Instructors can go too slowly, either because they are not good
  typists or by spending too much time looking at notes to try to
  remember what they meant to type.

\item Typing in boilerplate code that is needed by the lesson, but not
  directly relevant to it (such as library import statements), can
  distract learners from the intended thrust of a lesson.  As
  \citet{willingham-book} says, ``Memory is the residue of thought'';
  if the instructor spends their time typing boilerplate, that may be
  all that learners take away.

\end{enumerate}

\section{Have students make predictions}\label{predictions}

When instructors are using live coding,
they usually run the program several times during its development to show what it does.
Research from peer instruction in physics education shows that
learners who observe a demonstration do not learn better than
those who did not see the demonstration~\citep{crouch-demo},
and in fact many learners misremember the outcome of demonstrations afterwards~\citep{miller-demo}.

The key to making demonstrations more effective is
to make learners predict the outcome of the demonstration before performing it.
Crucially, their prediction should be in some way recorded or public,
e.g. by a show of hands,
by holding up a cue card (A/B/C/D),
or by talking to their neighbour.
We speculate that the sting of possibly being publicly wrong leads learners to pay more attention
and to reflect on what they are learning;
regardless of whether this hypothesis is true,
instructors should be careful not to punish or criticise students who predicted wrongly,
but rather to use those incorrect predictions as a spur to further exploration.

\section{Use pair programming}\label{pair-programming}

Pair programming is a software development practice
in which two programmers share one computer.
One person (called the driver) does the typing,
while the other (called the navigator) offers comments and suggestions.
The two switch roles several times per hour.
Pair programming is a good practice in real-life programming \cite{hannay},
and also a good way to teach \cite{mcdowell}.
Partners can not only help each other out during practical exercises,
but can also clarify each other's misconceptions when the solution is presented.

Both parties involved in pair programming learn while doing it.
The weaker gets individual instruction from the stronger,
while the stronger learns by explaining,
and by being forced to reconsider things which they may not have thought about in a while.
When pair programming is used it is important to put everyone in pairs,
not just the learners who may be struggling,
so that no one feels singled out.
It's also important to have people switch roles within each pair three or four times per hour,
so that the stronger personality in each pair does not dominate the session.

\section{Use worked examples with labelled subgoals}\label{worked-examples}

Learning to program involves learning the syntax and semantics of a programming language,
but also involves learning how to construct programs.
A good way to guide students through constructing programs is the use of worked examples:
step-by-step guides showing how to solve an existing problem.

A good idea when teaching is
to provide many similar examples for learners to practice on.
But since learners are novices,
they may not see the similarity between examples:
finding the highest rainfall from a list of numbers
finding the first surname alphabetically from a list of names
may seem like quite different problems to them.

\citet{morrison-subgoals,morrison-parsons} have shown that students perform better
when worked examples are broken down into steps (or subgoals)
which are given names (or labels).
Subgoal labels provide a structure which students can apply to future tasks that they attempt themselves,
and allow them to communicate with their peers and instructors more efficiently.

% FIXME give a short code snippet here with some subgoal labels to illustrate - yes please

\section{Stick to one language}\label{one-language}

A principle that applies across all areas of education is that transference only comes with mastery \cite{gick-holyoak}.
Courses should therefore stick to one language until learners have progressed far enough with it
to be able to distinguish the forest from the trees.
While an experience programmer can,
for example,
take what they know about loops and function calls in one language
and re-use that understanding in a language with a different syntax or semantics,
a newcomer does not yet know which elements of their knowledge are central
and which are accidental.
Attempting to force transference too early---i.e.,
requiring them to switch from Python to JavaScript in order to do a web programming course
early in their education---will confuse learners and erode their confidence.

\section{Use authentic tasks}\label{authentic-tasks}

Guzdial et al.\ found that having learners manipulate images, audio, and video
in their early programming assignments
increased retention in two senses:
learners remembered more of the material when re-tested after a delay,
and were more likely to stay in computing programs \cite{guzdial-media}.
This is a particular instance of a larger observation:
learners find authentic tasks more engaging than abstracted examples.

A classic question in computing (and mathematics) education is whether problems are better 
with context (e.g. find the highest student grade) or without (e.g. find the maximum of the list of numbers).
\citet{bouvier-context} studied this with a multi-university study and found no difference between
the two.  They suggest that since it makes no difference, other considerations (such as motivation)
should be primary.

One caution is that context can inadvertently exclude some people while drawing others in.
For example,
many educators use computer games as a motivating example for programming classes,
but some learners may associate them with violence and racial or gender stereotypes.

\section{Don't just code}\label{not-just-code}

Our final rule for teaching programming is that you don't have to program to do it.
Between syntax, semantics, algorithms, and design,
examples that seem small to instructors can easily overwhelm novices.
Breaking the problem down into smaller single-concept pieces can reduce the cognitive load to something manageable.

For example,
a growing number of educators are including Parsons Problems in their pedagogic repertoire~\citep{parsons,morrison-parsons}.
Rather than writing programs from scratch,
learners are given the lines of code they need to solve a problem,
but in jumbled order.
Re-ordering them to solve the problem correctly allows them to concentrate on mastering control flow
without having to devote mental energy to recalling syntax
or the specifics of library functions.

\section{Novices are not experts}\label{not-experts}

This principle sounds tautological, but it is easily forgotten.
Novices program differently than experts,
and need different approaches or tools.
If you ask a professional programmer to iterate over a list of integers and produce the average,
they can write the code within seconds,
using stored knowledge of the exact pattern required.
A novice will approach this problem totally differently:
they need to remember the syntax for the different parts,
they need to know how to iterate over a list,
how to use an accumulator variable,
and so on.

Novices may need to spend time thinking about an algorithm on paper
(something expert programmers rarely need,
as they have usually memorised most common algorithmic patterns).
They may need to construct examples in guided steps.
They may struggle to debug.
Debugging usually involves contrasting what is happening to what should be happening,
but a novice's grasp on what should be happening is usually fragile.

Novices do not become professionals simply by doing what professionals do at a slower pace.
We do not teach reading by taking a classic novel and simply proceeding more slowly.
We teach by using shorter books with simpler words and larger print.
So in programming,
we must take care to use small, self-contained tasks at a level suitable for novices,
with tools that suit their needs.

\section*{Conclusion}

Like anything involving human subjects,
studies of computing education must necessarily be hedged with qualifiers.
However,
we do know a great deal,
and are learning more each year.
Venues like SIGCSE (\url{http://sigcse.org/}) and ITiCSE (\url{http://iticse.acm.org/})
present a growing number of rigorous, insightful studies
with immediate practical application.
Future work may overturn or qualify some of our ten simple rules,
but they form a solid basis for any educational effort.

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
